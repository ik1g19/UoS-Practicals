# Memory Forensics

Memory Forensics is the process of acquiring an analyzing physical memory (Called System Memory or RAM) in order to find artifacts and evidence

For complete analysis, memory forensics is performed in conjunction with disk and network forensics

Fileless malware != memory-only Malware
- Memory-Only doesn't survive reboots (but may be re-infected over the network, etc)
- Fileless can persist in the registry or some SPI/EEPROM storage in the system

What can be Recovered
- Disk Encryption Keys
- Loaded Kernel Drivers
- Malware Created Artifacts
- Application information o (URL history, chat logs, emails)
- Running Processes
- Active Network Connections
- A lot more...

| Function | Sysinternal | Volatility |
| :--- | :--- | :--- |
| Running Processes | x | x |
| Terminated Processes |  | x |
| Hidden Processes |  | x |
| Open Handles | x | x |
| Network Connections and Sockets | x | x |
| Kernel Modules |  | x |
| Process dumps | x | x |
| strings | x |  |
| Logged On Users | x | x |
| Command shell history |  | x |
| MFT & MBR analysis |  | x |
| Cached files and registry |  | x |
| Rootkits and API hooks | Limited | Robust |

## Why is this Important

Can recover the entire state of the operating system
- Applications

Can also uncover entire historical information
- E.g. processes that executed and terminated in the past

Some of the data recovered from memory is never written to disk or the network
- Browser in private mode

Advanced and Stealthy malware operates only in memoy

Note: You can still run all the Malware and Incident Response tools, However, you run them after collecting the memory

## Memory Forensics

OS can see running processes

Memory forensics can see new and old data

![|600](notes/Software%20Security/Images/Pasted%20image%2020230412220117.png)

## Memory Analysis

1. Lost when host is rebooted or shut down (It is called volatile for a reason)
2. Not as structured as filesystems
3. Dependent on the operating system behavior
4. Sometimes data is not available in memory (paged to swap disk)

### Analysis Techniques
Unstructured
- Tools: Strings, less, regexp
- Search: passwords, logs, domains
- Example: strings mem.ram | grep -i password

Structured
- Reconstruct operating system abstractions (Process list, process heap, process stack)
- Interpret data in System memory just like tools on the operating system (ls, ps, ..)

File Craving
- Office files, images, pictures, archives

![|400](notes/Software%20Security/Images/Pasted%20image%2020230412220534.png)

### OS Internals
Data Structures are used by the $\mathrm{OS}$ to store data in an organized fashion
- Each data structure has delete, insert, modify operation

We need the knowledge of the data structure in order to model memory analysis offline

Array
- Contiguous elements

Strings
- Unicode (2 bytes each)
- NULL Terminated

![|600](notes/Software%20Security/Images/Pasted%20image%2020230412220705.png)

### Doubly Linked List

![|600](notes/Software%20Security/Images/Pasted%20image%2020230412220738.png)

### Memory Management
Physical memory refers to all slots that are physically present on RAM

Covers and track all allocation of these physical addresses

Cover setting up Virtual Addresses

When pages are requested but physical memory is used, the OS uses a secondary storage to make a place in the physical memory
- This can affect the analysis if we are looking at the memory only

![|600](notes/Software%20Security/Images/Pasted%20image%2020230412220833.png)

### Page Files/Swap Disk
Non-Pages memory can never be swapped
- Some Kernel Data

Anything in paged memory is a candidate

Registry keys and PE headers

Frequently accessed pages

When a file is mapped into process, the virtual memory is reserved but physical pages are not allocated
- Allocation only on first access

Several acquisition tools can collect the pagefiles, but all tools are required to run on the same machine

### Intel/ADM Architecture
Virtual Memory
- X86
	- 32bit virtual \& physical addresses - 4GB
	- 2GB user and 2GB kernel
- X86 with PAE
	- 32 bit virtual, 36 bit physical address - 64GB
- X86_64
	- 64 bit virtual, 48bit physical address - 256TB
	- User mode - 8TB

### Address Translation
At the end of the day, we will be analyzing raw data.
- We will find Virtual Addresses in memory and we will need to find the matching physical address

In a running system, the CPU translate the virtual address to physical address to access the memory (RAM)
What does it mean for a memory forensics tool?
- It must implement the same address translation algorithm as the CPU

### Memory Aquisition
First step in the memory analysis process is to acquire reliable data 
- If this step is not right, analysis won't be possible

Acquisition means acquiring data from the Volatile memory (RAM) to non-volatile storage

When to acquire the data
- Not during time of heavy execution and massive changes.
- You might want to avoid:
	- Antivirus scan
	- System backup
- You might want to stop your interactions with the machine until the memory acquisition is done

### Acquisition Methods
If your target is a virtual machine
- Use the hypervisor
	- Pause, Snapshot, Continue Running
- Qemu has the option to move to shell mode and perform memory acquisition
- You might want to introspect the machine
- Valid if you have the right access
- Disadvantage: might be slow

If machine is not running
- Collect dump files, hibernation files, filepage

If machine is locked/no admin access
- Hardware based approaches

### Hardware Acquisition Method
Firewire
- Old protocol that works only on $<4 \mathrm{~GB}$
- Not in use anymore

PCI/USB-C/Thunerbold
- Commercial options are very expensive
- Some experimental platform
- PCILeech (Open Source)
- PCIe Gen 5 operates at 32Gbps for $\mathrm{x} 1->256 \mathrm{Gbps}$ for x8

### Hardware Challenges
Need to have hardware device installed in advance

Firewire DMA is disabled in new OS (Mac, Windows 8)

VT-D enable -> IOMMU
- See IO-Trust for solution (Atamli et al., 2019)

### What could go wrong with the Acquisition
- Change CPU state (tampering with the evidence)
	- Caches, TLB, registers
- Some ranges (e.g. PCIE regions) can cause Kernel Panic
- Virtual Secure Mode is not accessible
- Performance is impacted due to many cache invalidations
- Malware spreading to USB?
- Malware capture your login keystrokes
	- Make sure you are disconnected from the network

### Acquistion Tools
- Lime - Linux Memory Extractor
- Winpmem

### Volatility
Open Source Forensics Framework
- https://github.com/volatilityfoundation/volatility

Plugins to analyze Windows, Linux, macOS memory dumps

Used by Forensics Investigators and Researchers

Basis for Virtual Machine Introspection
- Libvmi

Compile many published malware research

Yearly competition of best new plugins with cash prices

Can be used as a library or interactive mode using the shell

#### Framework
- Cohesive framework
	- 86 PAE, non-PAE) and x64 windows 10
	- x86/x64 linux/mac
	- 32 bit android
- Open Source, GNU GPLv2
- Python
	- Uses distorm3, pycrypto, yara
- Support for $10+$ memory dumps/process dump
	- Raw, crash, hiber,Vmware, virtualbox, qemu, hpak, lime, ewf, firewire, hyper-v, xen, kvm
- Fast
	- For offline forensics research
	- Do not confuse this with a debugger!

#### Volatility Profiles
Sets of profiles are already available

Might need to make your own profile
- Will be needed when working with Linux

```bash
$ python vol.py --info
```

| Profiles| |
| :---: | :---: |
| VistaSP0x64 - | - A Profile for Windows Vista SP0 x64 |
| VistaSP0x86 - | - A Profile for Windows Vista SP0 x86 |
| VistaSP1x64 - | - A Profile for Windows Vista SP1 x64 |
| VistaSP1x86 - | - A Profile for Windows Vista SP1 x86 |
| Win 10 xx64 | A Profile for Windows 10 xx64 |
| Win10x64_10240_17770 | - A Profile for Windows 10 x64 (10.0.10240.17770 / 2018-02-10) |
| Win10x64-10586 | - A Profile for Windows 10 x64 (10.0.10586.306 / 2016-04-23) |
| Win 10 xx6414393 | - A Profile for Windows 10 x64 (10.0.14393.0 / 2016-07-16) |
| Win10x64_15063 | - A Profile for Windows 10 x64 (10.0.15063.0 / 2017-04-04) |
| Win10x64-16299 | - A Profile for Windows 10 x64 (10.0.16299.0 / 2017-09-22) |
| Win10x64 17134 | - A Profile for Windows 10 x64 (10.0.17134.1 / 2018-04-11) |
| Win10x64_17763 | - A Profile for Windows 10 xx64 (10.0.17763.0 / 2018-10-12) |
| Win10x64- 18362 | - A Profile for Windows 10 x64 (10.0.18362.0 / 2019-04-23) |
| Win10x86 14393 | - A Profile for Windows 10 x86 (10.0.14393.0 / 2016-07-16) |
| Win10x86 15063 | - A Profile for Windows 10 x86 (10.0.15063.0 / 2017-04-04) |
| Win2008R2SP0x64 | - A Profile for Windows 2008 R2 SPO x64 |

#### Volatility Plugins

```bash
$ volatility.py --h
```

| Plugin | |
|------------------------|-------------------------------------------------------------------------------|
| atoms          |  - Print session and window station atom tables                       |
|  atomscan     | - Pool scanner for atom tables                                       |
|  bigpools     | - Dump the big page pools using BigPagePoolScanner                   |
|  bioskbd      | - Reads the keyboard buffer from Real Mode memory                    |
|  callback    | - Print system-wide notification routines                            |
|  clipboar    | - Extract the contents of the windows clipboard                      |
|  cmdline      | - Display process command-line arguments                             |
|  cmdscan      | - Extract command history by scanning for COMMAND_HISTORY           |
|  connections   | - Print list of open connections [Windows XP and 2003 Only]          |
|  connscan    | - Pool scanner for tcp connections                                   |
|  consoles    | - Extract command history by scanning for_CONSOLE_INFORMATION        |
|  crashinfo   | - Dump crash-dump information                                        |
|  deskscan    | - Poolscaner for tagDESKTOP (desktops)                               |
|  devicetree   | - Show device tree                                                   |
|  dlldump      | - Dump DLLs from a process address space                             |
|  dlllist      | - Print list of loaded dlls for each process                         |
|  driverirp    | - Driver IRP hook detection                                          |
|  drivermodule | - Associate driver objects to kernel modules                         |
|  driverscan  | - Pool scanner for driver objects                                    |
|  dumpcerts   | - Dump RSA private and public SSL keys                               |
|  dumpfiles   | - Extract memory mapped and cached files                             |
|  editbox    | - Displays information about Edit controls. (Listbox experimental.)  |
|  eventhooks   | - Print details on windows event hooks                               |
|  filescan     | - Pool scanner for file objects                                      |

```bash
$ volatility.py -f memory.raw -profile=PROFILE PLUGIN [OPTIONS]
```

```bash
# Avilable plugins and operation. If you add new plugin it’s suffice to add it to the right directory
$ volatility.py -h
```

```bash
# provide information on the plugin and how its used
$ volatility.py <plugin> -h
```

```bash
# provide general information on the profiles, address spaces
$ volatility.py --info
```

#### If you don't know the Profile
Use KDBG scan

```bash
vol/volatility$ python2.7 vol.py -f ./mem_dumps/xp-laptop-2005-06-25.img kdbgscan
```

![|600](notes/Software%20Security/Images/Pasted%20image%2020230413003509.png)

#### Processes

```bash
vol/volatility$ python2.7 vol.py -f ./mem_dumps/xp-laptop-2005-06-25.img pslist
```

![|600](notes/Software%20Security/Images/Pasted%20image%2020230413004147.png)

### Windows Object Manager
Structure vs Object?
- A structure becomes an object when Windows appends various headers to the start of the structure to manage services such as naming, access control, and reference counts

Files, drivers, mutexes, processes, threads, events

Est. 45 object types on Windows 7

Allocation/deallocation of objects

Access to objects

| Object Type | Structure | Description |
| :--- | :--- | :--- |
| Process | \_EEPROCESS | A process |
| Thread | \_ETHREAD | A thread |
| File | \_FILE_OBJECT | An open instance of a file |
| Key | \_CM_KEY_BODY | An open instance of a registry key |
| Mutant | \_KMUTANT | A mutex object |
| Driver | \_DRIVER_OBJECT | A driver object |
| Token | \_TOKEN | An object that stores security/ access controls  |
| SymbolicLink | \_OBJECT_SYMBOLIC_LINK | Alliases (driver letters etc) |

#### X86 Object Format
![|600](notes/Software%20Security/Images/Pasted%20image%2020230413004653.png)

#### Object Header (Pre Windows 7)
`... dt (“_OBJECT_HEADER”)`
`‘_OBJECT HEADER’ (32 bytes)`

![|600](notes/Software%20Security/Images/Pasted%20image%2020230413004805.png)

#### Object Types
Define common properties for objects of a particular type
- Name ("Process")
- Counters (TotalNumberOfObjects)
- Default access rights
- Initialisation
	- What type of memory (paged, non-paged)
- \_OBJECT_TYPE.Key-4 byte identifier
	- 4 ASCII characters
	- Useful for finding objects in memory
These tell us where to look (pages or non-paged memory) and what to look for (4 byte "tag")

#### Kernel Pool Allocation
User APIs lead to creation of kernel objects
- `CreateFile`, `CreateMutex`...

Objects are allocated from system memory pools

`ObCreateObject()` calls `ExAllocatePoolWithtag()`

Prepends `_POOL_HEADER` to the start of the allocation

If all objects exist in pools, and at the base of every pool allocation is a `_POOL_HEADER`. If we can "fingerprint" the `_POOL_HEADER`, it would give us a more reliable way to find all objects

#### Object within a Pool

![|600](notes/Software%20Security/Images/Pasted%20image%2020230413010242.png)

#### Pool Headers

![|600](notes/Software%20Security/Images/Pasted%20image%2020230413010337.png)

#### Scanning for Objects in Pools
Are the objects in paged or non-paged memory?
- Taken from `_OBJECT_TYPE.TypeInfo.PoolType`

What is the pool tag?
- Taken from `_OBJECT_TYPE.Key`
- May be protected (MSB)

What size are the allocations?
- Minimum can be taken from Profile.get_obj_size0 which returns the Vtype structure size
- BlockSize \* pool alignment $==$ total size of allocation
	- 8 bytes on $x 86,16$ bytes on $x 64$

#### Volatility Scanning Criteria

![|600](notes/Software%20Security/Images/Pasted%20image%2020230413010813.png)

#### Why Pool Tagging
- Windows tags pools for debugging purposes
- Memory management statistcs
- Evaluating the pool tag usage can tell you what percent of memory is tied to a particular $\operatorname{tag}$
- You can then track it back to a driver (and perhaps a function within the driver)
- We leverage what Microsoft built-in for identifying memory leaks to strengthen memory forensics

##### Disadvantages
- Pool tags are not OS essential, this they can be modified without causing instability
- Pools can be e-used for similarly sized or smaller allocations (thus evidence of some types may be short-lived)
	- Last in/ first out schedule
- Decoys / fake objects
	- As a result of being non-essential, they can be faked

#### Processes (`_EPROCESS`)
- Container for resources used when executing a program
- Private virtual address space (DTB) except shared memory and most of kernel memory
- Executable instructions (PE, DLLs)
- Open handles
- Security context (SIDs, privileges)
- Thread(s) of execution

#### Crticial System Processes
- `Isass.exe` -local authority (password changes, creates access tokens, etc) System container for threads that run in kernel mode
- `smss.exe` - session manager subsystem
- `services.exe`- service control manager
- `csrss.exe` - client/server runtime subsystem (creation of processes and threads, console windows, etc)
- `winlogon.exe` - interactive logon manager
- `explorer.exe` - Windows explorer
- `svchost.exe` - shared service host process

#### Process Relationships
Red flags:
- `cmd.exe` as child of browsers, office applications, email clients, etc.
- `svchost.exe`, with a parent other than services.exe or that aren't running a service (xref with svscan)
- Network connections initiated by `msiexec.exe` (plugx)

#### `PsActiveProcessHead`
Doubly-linked list head pointed to by KDBG

All live APIs reference this list (indirectly)
- `NtQuerySystemInformation()` with `SystemInformationProcess` class
- `CreateToolhelp32Snapshot()` with `Process32First()`/`Process32Next()`
- WMI `Win32_Process` class
- `EnumProcesses()` from `psapi.dll`

Kernel mode process list?
- `PsGetCurrentProcess()`
- `Nt!PsInitialSystemProcess`

PsActiveProcessHead may contain terminated processes
- Can be terminated and stull in the list
- Objects aren't deleted/removed until the reference count reaches zero
- Parent process forgets to close its handle

Indicators of active vs unactive
- Exit time
- Number of threads (must be $>0$ )
- Number of handles (must be $>0$ )

#### Hiding Processes with DKOM

![|600](notes/Software%20Security/Images/Pasted%20image%2020230413011753.png)

##### User Mode
- On older systems you could do this with the proper privileges and `ZwSystemDebugControl` (XP/2003 only)
- Or by mapping $\backslash$ Device $\backslash$ PhysicalMemory on systems that allow it (XP/2003 only)
- Find one process, walk the list to your target process
- Overwrite the Flink and Blink members of `_LIST_ENTRY`

##### Kernel Mode
- Loading a driver to access the kernel mode structures
- Driver must be signed on 64-bit systems
- Recent Windows 10: Microsoft must cross-sign the driver (in addition to the CA)
- Patchguard protection on newer systems


#### Process Object Scanning
In the event of DKOM, we need a way to still find the process objects
- Provided no further tampering has occurred

Can find terminated processes or residual (left-over from reboot, etc)
- This is why we use psscan most often in modern systems

Methods
- Dispatcher header
- Pool header (the only one currently in use:psscan)
- Robust scanning

##### Scanning with `psscan`

```bash
/vol/volatility$ python2.7 vol.py -f ./mem_dumps/dkom.mem psscan
```

![|600](notes/Software%20Security/Images/Pasted%20image%2020230413012204.png)

#### Alternate Process Listings
If malware hides in multiple ways, we need multiple ways to find them
- PsActiveProcessHead traversal
- Pool tag scanning of processes
- Pool tag scanning for threads
	- Even hidden processes need at least one thread of execution
- PsCidTable
- Csrss.exe handle table
- Win32k subsystem structures

#### Scanning for Threads
- Windows XP and 2003
	- `_ETHREAD.ThreadsProcess` (PEPROCESS)
- Windows Vista, 2008 and 7
	- `_ETHREAD.Tcb.Process` (PEPROCESS)
- All versions of Windows
	- `_ETHREAD.Cid.UniqueProcess` (unit)
- Abstracted with inheritance in Volatilit's API
- `_ETHREAD.owning_process()`
- Attacks: thread pool header manipulation

#### PsCidTable
Special handle table (`_HANDLE_TABLE`) for tracking processes and threads

Pointed to by `KDBG.PspCidTable`, resides in kernel memory

Attacks: manipulated by FuTo to hide from Backlight and IceSword

#### `Csrss.exe`
Client-server runtime subsystem

Involved in the creation of every process and thread - What happens if a `csrss.exe` craches?

Maintain an open handle to all objects during their lifetime

Attacks: given the proper permissions, it is possible to close the handles